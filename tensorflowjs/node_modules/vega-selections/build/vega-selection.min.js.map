{"version":3,"file":"vega-selection.min.js","sources":["../../../node_modules/d3-array/src/ascending.js","../../../node_modules/internmap/src/index.js","../../../node_modules/d3-array/src/intersection.js","../src/constants.js","../src/selectionTest.js","../../../node_modules/d3-array/src/bisector.js","../src/selectionResolve.js","../../../node_modules/d3-array/src/union.js","../src/selectionTuples.js","../src/selectionVisitor.js"],"sourcesContent":["export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","export class InternMap extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (entries != null) for (const [key, value] of entries) this.set(key, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n}\n\nexport class InternSet extends Set {\n  constructor(values, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (values != null) for (const value of values) this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n}\n\nfunction intern_get({_intern, _key}, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\n\nfunction intern_set({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\n\nfunction intern_delete({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\n\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n","import {InternSet} from \"internmap\";\n\nexport default function intersection(values, ...others) {\n  values = new InternSet(values);\n  others = others.map(set);\n  out: for (const value of values) {\n    for (const other of others) {\n      if (!other.has(value)) {\n        values.delete(value);\n        continue out;\n      }\n    }\n  }\n  return values;\n}\n\nfunction set(values) {\n  return values instanceof InternSet ? values : new InternSet(values);\n}\n","import {field} from 'vega-util';\n\nexport const Intersect = 'intersect';\nexport const Union = 'union';\nexport const VlMulti = 'vlMulti';\nexport const VlPoint = 'vlPoint';\nexport const Or = 'or';\nexport const And = 'and';\n\nexport const SelectionId = '_vgsid_';\nexport const $selectionId = field(SelectionId);\n","import {bisector} from 'd3-array';\nimport {$selectionId, Intersect} from './constants';\nimport {field, inrange, isArray, isDate, toNumber} from 'vega-util';\n\nconst TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    UNIT_INDEX = 'index:unit';\n\n// TODO: revisit date coercion?\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0, dval, f;\n\n  for (; i<n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if(isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nexport function selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}\n\nconst bisect = bisector($selectionId),\n  bisectLeft = bisect.left,\n  bisectRight = bisect.right;\n\nexport function selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      value = $selectionId(datum),\n      index = bisectLeft(entries, value);\n\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n","import ascending from \"./ascending.js\";\n\nexport default function bisector(f) {\n  let delta = f;\n  let compare1 = f;\n  let compare2 = f;\n\n  if (f.length !== 2) {\n    delta = (d, x) => f(d) - x;\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n","import {intersection, union} from 'd3-array';\nimport {array, toNumber} from 'vega-util';\nimport {$selectionId, And, Or, SelectionId, Union, VlMulti, VlPoint} from './constants';\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\nexport function selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {}, multiRes = {}, types = {},\n    entry, fields, values, unit, field, value, res, resUnit, type, union,\n    n = entries.length, i = 0, j, m;\n\n  // First union all entries within the same unit.\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    if (fields && values) { // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[`${type}_union`];\n        res[unit] = union(resUnit, array(values[j]));\n      }\n\n      // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    } else {  // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push({[SelectionId]: value});\n      }\n    }\n  }\n\n  // Then resolve fields across units as per the op.\n  op = op || Union;\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));\n  } else {\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field])\n        .map(unit => resolved[field][unit])\n        .reduce((acc, curr) => acc === undefined ? curr : ops[`${types[field]}_${op}`](acc, curr));\n    });\n  }\n\n  entries = Object.keys(multiRes);\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union\n      ? {[Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])}\n      : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  [`${SelectionId}_union`]: union,\n  [`${SelectionId}_intersect`]: intersection,\n\n  E_union: function(base, value) {\n    if (!base.length) return value;\n\n    var i = 0, n = value.length;\n    for (; i<n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n    return base;\n  },\n\n  E_intersect: function(base, value) {\n    return !base.length ? value :\n      base.filter(v => value.indexOf(v) >= 0);\n  },\n\n  R_union: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n\n  R_intersect: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n    return base;\n  }\n};\n","import {InternSet} from \"internmap\";\n\nexport default function union(...others) {\n  const set = new InternSet();\n  for (const other of others) {\n    for (const o of other) {\n      set.add(o);\n    }\n  }\n  return set;\n}\n","import {extend, field} from 'vega-util';\nimport {$selectionId, SelectionId} from './constants';\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} base  - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\nexport function selectionTuples(array, base) {\n  return array.map(x => extend(\n    base.fields ? {\n      values: base.fields.map(f => (f.getter || (f.getter = field(f.field)))(x.datum))\n    } : {\n      [SelectionId]: $selectionId(x.datum)\n    }, base));\n}\n","import {Intersect} from './constants';\nimport {Literal} from 'vega-expression';\nimport {error, hasOwnProperty, peek} from 'vega-util';\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nexport function selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n"],"names":["ascending","a","b","NaN","InternSet","Set","constructor","values","key","keyof","super","Object","defineProperties","this","_intern","value","Map","_key","add","has","_ref","get","intern_get","_ref2","set","intern_set","delete","_ref3","intern_delete","valueOf","Intersect","Union","SelectionId","$selectionId","field","UNIT_INDEX","testPoint","datum","entry","dval","f","fields","n","length","i","getter","isDate","toNumber","map","type","isArray","indexOf","inrange","bisect","delta","compare1","compare2","left","x","lo","hi","arguments","undefined","mid","d","center","right","bisector","bisectLeft","bisectRight","ops","_len","others","Array","other","o","out","E_union","base","push","E_intersect","filter","v","R_union","R_intersect","name","op","data","context","entries","unitIdx","intersect","index","size","isMulti","vl5","unit","res","resUnit","union","j","m","resolved","multiRes","types","charAt","concat","array","reduce","obj","curr","keys","forEach","acc","Or","k","and","or","miss","count","extend","args","scope","params","Literal","error","indexName","IndexPrefix","dataName","peek","hasOwnProperty","getData","indataRef","tuplesRef"],"mappings":"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"}